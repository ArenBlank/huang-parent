# 健身平台技术架构与外部服务集成文档

> **文档版本**: v1.0
> **创建日期**: 2025-01-24
> **适用范围**: 健身平台单体应用（Spring Boot 3.0.5 + Vue 3）
> **维护者**: 开发团队

---

## 📋 目录

- [一、技术架构总览](#一技术架构总览)
- [二、核心技术栈详解](#二核心技术栈详解)
- [三、中间件集成方案](#三中间件集成方案)
  - [3.1 MySQL 8.0 数据持久化](#31-mysql-80-数据持久化)
  - [3.2 Redis 缓存与会话管理](#32-redis-缓存与会话管理)
  - [3.3 MinIO 对象存储](#33-minio-对象存储)
- [四、外部API服务集成](#四外部api服务集成)
  - [4.1 高德地图API](#41-高德地图api)
  - [4.2 短信验证码服务](#42-短信验证码服务)
  - [4.3 支付服务集成](#43-支付服务集成)
- [五、项目实现功能清单](#五项目实现功能清单)
- [六、完整集成实战指南](#六完整集成实战指南)
- [七、生产环境部署清单](#七生产环境部署清单)

---

## 一、技术架构总览

### 1.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           前端层（Vue 3）                                 │
├──────────────────────────────┬──────────────────────────────────────────┤
│      Admin管理端              │           App用户端                       │
│  - Element Plus UI           │      - Vant 3 移动端UI                    │
│  - Vue Router 4              │      - Vant Weapp 小程序                  │
│  - Pinia状态管理              │      - 高德地图JS API                     │
│  - Axios HTTP客户端          │      - Axios HTTP客户端                   │
└──────────────┬───────────────┴──────────────┬───────────────────────────┘
               │                              │
               │          HTTPS/HTTP          │
               │                              │
┌──────────────┴──────────────────────────────┴───────────────────────────┐
│                      应用层（Spring Boot 3.0.5）                         │
├──────────────────────────────┬──────────────────────────────────────────┤
│   web-admin模块               │        web-app模块                        │
│   ├─ Controller              │        ├─ Controller                      │
│   ├─ Service                 │        ├─ Service                         │
│   ├─ Mapper                  │        ├─ Mapper                          │
│   └─ Config                  │        └─ Config                          │
├──────────────────────────────┴──────────────────────────────────────────┤
│                        共享层（common + model）                          │
│   ├─ Entity实体类            ├─ DTO/VO                                   │
│   ├─ 统一结果封装             ├─ 工具类                                   │
│   ├─ 全局异常处理             ├─ 配置类                                   │
│   └─ 统一拦截器               └─ 常量定义                                 │
└───────────────┬──────────────┬──────────────┬──────────────┬────────────┘
                │              │              │              │
       ┌────────┴────┐  ┌──────┴──────┐ ┌────┴─────┐  ┌────┴──────┐
       │   MySQL     │  │   Redis     │ │  MinIO   │  │ 外部API    │
       │   数据库     │  │   缓存      │ │ 对象存储  │  │  服务      │
       └─────────────┘  └─────────────┘ └──────────┘  └───────────┘
              │                │              │              │
       ┌──────┴──────┐  ┌──────┴──────┐ ┌────┴─────┐  ┌────┴──────┐
       │ - 业务数据   │  │ - Session   │ │ - 图片   │  │ - 高德地图 │
       │ - 用户信息   │  │ - Token黑名单│ │ - 视频   │  │ - 短信验证 │
       │ - 订单记录   │  │ - 热点数据   │ │ - 文件   │  │ - 支付网关 │
       │ - 健康档案   │  │ - 限流计数   │ │          │  │           │
       └─────────────┘  └─────────────┘ └──────────┘  └───────────┘
```

### 1.2 技术选型一览表

| 层次 | 技术/中间件 | 版本 | 用途 | 是否必需 |
|------|------------|------|------|---------|
| **后端框架** | Spring Boot | 3.0.5 | 应用基础框架 | ✅ 必需 |
| **持久层** | MyBatis-Plus | 3.5.3.1 | ORM框架 | ✅ 必需 |
| **数据库** | MySQL | 8.0+ | 关系型数据库 | ✅ 必需 |
| **缓存** | Redis | 7.0+ | 分布式缓存 | ✅ 必需 |
| **对象存储** | MinIO | 8.2.0 | 文件存储 | ✅ 必需 |
| **API文档** | Knife4j | 4.1.0 | Swagger增强 | ✅ 必需 |
| **安全认证** | JWT | jjwt 0.11.5 | 无状态认证 | ✅ 必需 |
| **JSON处理** | Jackson | 2.14.2 | JSON序列化 | ✅ 必需 |
| **日志框架** | Logback | 1.4.5 | 日志记录 | ✅ 必需 |
| **外部API-地图** | 高德地图API | - | 地理位置服务 | 🔧 推荐 |
| **外部API-短信** | 阿里云SMS / 腾讯云SMS | - | 短信验证码 | 🔧 推荐 |
| **外部API-支付** | 微信支付 / 支付宝 | - | 在线支付 | 🚀 可选 |
| **前端框架** | Vue 3 | 3.3+ | 渐进式框架 | ✅ 必需 |
| **移动端UI** | Vant | 4.0+ | 移动端组件库 | ✅ 必需 |
| **管理端UI** | Element Plus | 2.3+ | PC端组件库 | ✅ 必需 |

**图例说明**：
- ✅ 必需：项目核心依赖，必须配置
- 🔧 推荐：增强功能，建议集成
- 🚀 可选：扩展功能，按需集成

---

## 二、核心技术栈详解

### 2.1 Spring Boot 3.0.5

**选型原因**：
- Jakarta EE 9+ 支持（替代 javax.*）
- 原生支持 GraalVM（可编译为原生镜像）
- 性能提升 30%（相比 Spring Boot 2.x）
- 最新安全补丁和特性

**核心依赖配置** (`pom.xml`)：
```xml
<!-- 父项目 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.0.5</version>
</parent>

<dependencies>
    <!-- Web Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- AOP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
</dependencies>
```

**项目中的应用**：
1. **统一结果封装** (`common/result/Result.java`)：
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Result<T> {
    private Integer code;
    private String message;
    private T data;

    public static <T> Result<T> success() {
        return new Result<>(200, "成功", null);
    }

    public static <T> Result<T> success(T data) {
        return new Result<>(200, "成功", data);
    }

    public static <T> Result<T> fail(String message) {
        return new Result<>(500, message, null);
    }
}
```

2. **全局异常处理** (`common/exception/GlobalExceptionHandler.java`)：
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // 业务异常
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.warn("业务异常: {}", e.getMessage());
        return Result.fail(e.getMessage());
    }

    // 参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        log.warn("参数校验失败: {}", message);
        return Result.fail(message);
    }

    // 系统异常
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.fail("系统繁忙，请稍后重试");
    }
}
```

---

### 2.2 MyBatis-Plus 3.5.3.1

**选型原因**：
- CRUD 零 SQL 配置（继承 BaseMapper）
- 强大的条件构造器（LambdaQueryWrapper）
- 内置分页插件（Page）
- 自动填充（createTime/updateTime）
- 逻辑删除支持

**依赖配置**：
```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.3.1</version>
</dependency>
```

**配置文件** (`application.yml`)：
```yaml
mybatis-plus:
  # Mapper XML 文件位置
  mapper-locations: classpath*:mapper/**/*.xml

  # 实体类包路径
  type-aliases-package: com.huang.model.entity

  # 全局配置
  global-config:
    db-config:
      # 主键策略（雪花算法）
      id-type: ASSIGN_ID
      # 逻辑删除字段
      logic-delete-field: isDeleted
      logic-delete-value: 1
      logic-not-delete-value: 0

  # MyBatis 原生配置
  configuration:
    # 驼峰转下划线
    map-underscore-to-camel-case: true
    # 日志输出（开发环境）
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

**项目中的应用**：

1. **BaseEntity 基类**：
```java
@Data
public class BaseEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    @TableLogic
    private Byte isDeleted;
}
```

2. **自动填充处理器**：
```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "isDeleted", Byte.class, (byte) 0);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
    }
}
```

3. **分页插件配置**：
```java
@Configuration
public class MybatisPlusConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());

        return interceptor;
    }
}
```

4. **Service层使用示例**（门店管理）：
```java
@Service
@RequiredArgsConstructor
public class GymStoreServiceImpl extends ServiceImpl<GymStoreMapper, GymStore>
        implements GymStoreService {

    @Override
    public Page<GymStoreListVO> getStoreListPage(GymStoreQueryDTO queryDTO) {
        // 构建分页对象
        Page<GymStore> page = new Page<>(queryDTO.getCurrent(), queryDTO.getSize());

        // 构建查询条件
        LambdaQueryWrapper<GymStore> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(GymStore::getIsDeleted, (byte) 0)  // 逻辑删除过滤
               .like(StringUtils.hasText(queryDTO.getStoreName()),
                     GymStore::getStoreName, queryDTO.getStoreName())
               .like(StringUtils.hasText(queryDTO.getAddress()),
                     GymStore::getAddress, queryDTO.getAddress())
               .eq(queryDTO.getStatus() != null,
                   GymStore::getStatus, queryDTO.getStatus())
               .orderByDesc(GymStore::getCreateTime);

        // 执行分页查询
        Page<GymStore> resultPage = this.page(page, wrapper);

        // 转换为VO
        return convertToVO(resultPage);
    }
}
```

---

### 2.3 JWT（JSON Web Token）认证

**选型原因**：
- 无状态认证（服务端不存储Session）
- 跨域友好（支持移动端/小程序）
- 包含用户信息（减少数据库查询）
- 支持分布式部署

**依赖配置**：
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

**项目中的应用**：

1. **JWT工具类** (`common/util/JwtUtil.java`)：
```java
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;  // 密钥（至少256位）

    @Value("${jwt.expiration}")
    private Long expiration;  // 过期时间（毫秒）

    // 生成Token
    public String generateToken(Long userId, String phone) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
                .setSubject(userId.toString())  // 用户ID
                .claim("phone", phone)          // 手机号
                .setIssuedAt(now)               // 签发时间
                .setExpiration(expiryDate)      // 过期时间
                .signWith(getSignKey(), SignatureAlgorithm.HS256)  // 签名算法
                .compact();
    }

    // 解析Token
    public Claims parseToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSignKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    // 从Token获取用户ID
    public Long getUserIdFromToken(String token) {
        Claims claims = parseToken(token);
        return Long.parseLong(claims.getSubject());
    }

    // 验证Token是否过期
    public boolean isTokenExpired(String token) {
        try {
            Claims claims = parseToken(token);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    // 获取签名密钥
    private Key getSignKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
```

2. **登录接口生成Token** (`web-app/controller/AuthController.java`)：
```java
@RestController
@RequestMapping("/app/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;
    private final JwtUtil jwtUtil;

    @PostMapping("/login")
    public Result<LoginVO> login(@Valid @RequestBody LoginDTO loginDTO) {
        // 1. 验证手机号和验证码
        User user = authService.verifyLoginCredentials(loginDTO);

        // 2. 生成JWT Token
        String token = jwtUtil.generateToken(user.getId(), user.getPhone());

        // 3. 返回用户信息和Token
        LoginVO loginVO = new LoginVO();
        loginVO.setToken(token);
        loginVO.setUserId(user.getId());
        loginVO.setNickname(user.getNickname());
        loginVO.setAvatar(user.getAvatar());

        return Result.success(loginVO);
    }
}
```

3. **Token拦截器** (`common/interceptor/JwtInterceptor.java`)：
```java
@Component
@RequiredArgsConstructor
public class JwtInterceptor implements HandlerInterceptor {

    private final JwtUtil jwtUtil;
    private final RedisTemplate<String, String> redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) {
        // 1. 获取Token
        String token = request.getHeader("Authorization");
        if (token == null || !token.startsWith("Bearer ")) {
            throw new UnauthorizedException("未登录或Token无效");
        }

        token = token.substring(7);  // 移除 "Bearer " 前缀

        // 2. 验证Token是否在黑名单（已退出登录）
        String blacklistKey = "token:blacklist:" + token;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(blacklistKey))) {
            throw new UnauthorizedException("Token已失效，请重新登录");
        }

        // 3. 解析Token
        try {
            Long userId = jwtUtil.getUserIdFromToken(token);

            // 4. 将用户ID存入ThreadLocal（供Controller使用）
            UserContext.setUserId(userId);

            return true;
        } catch (Exception e) {
            throw new UnauthorizedException("Token解析失败");
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler,
                                Exception ex) {
        // 清理ThreadLocal，防止内存泄漏
        UserContext.clear();
    }
}
```

4. **配置拦截器** (`common/config/WebConfig.java`)：
```java
@Configuration
@RequiredArgsConstructor
public class WebConfig implements WebMvcConfigurer {

    private final JwtInterceptor jwtInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(jwtInterceptor)
                .addPathPatterns("/app/**")  // 拦截App端所有接口
                .excludePathPatterns(
                    "/app/auth/login",       // 放行登录接口
                    "/app/auth/register",    // 放行注册接口
                    "/app/auth/send-code"    // 放行发送验证码
                );
    }
}
```

---

### 2.4 Knife4j API文档

**选型原因**：
- Swagger 3（OpenAPI 3.0）增强版
- 精美的UI界面
- 支持分组管理
- 在线调试功能

**依赖配置**：
```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
    <version>4.1.0</version>
</dependency>
```

**项目中的应用**（已在门店管理中实现）：
```java
@Configuration
public class Knife4jConfiguration {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("健身平台API")
                        .version("1.0")
                        .description("接口文档"))
                .addSecurityItem(new SecurityRequirement().addList("BearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("BearerAuth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")));
    }

    @Bean
    public GroupedOpenApi storeManagementAPI() {
        return GroupedOpenApi.builder()
                .group("10-门店管理")
                .pathsToMatch("/admin/gym-store/**")
                .build();
    }
}
```

**访问地址**：
- Swagger UI：`http://localhost:8080/doc.html`
- OpenAPI JSON：`http://localhost:8080/v3/api-docs`

---

## 三、中间件集成方案

### 3.1 MySQL 8.0 数据持久化

#### 3.1.1 技术特性

**选型原因**：
- ✅ JSON字段原生支持（`facilities` 字段存储门店设施信息）
- ✅ 空间索引（地理位置查询优化）
- ✅ 窗口函数（复杂统计查询）
- ✅ CTE递归查询（组织架构树）
- ✅ InnoDB引擎增强（性能提升40%）

#### 3.1.2 项目中的应用

**1. JSON字段存储**（`gym_store` 表）：
```sql
CREATE TABLE gym_store (
    id BIGINT PRIMARY KEY,
    store_name VARCHAR(50) NOT NULL,

    -- JSON字段存储设施信息
    facilities JSON COMMENT '设施信息: {"hasParking":true,"hasShower":true,...}',

    -- JSON字段存储图片数组
    images JSON COMMENT '门店图片: ["url1","url2",...]',

    -- 地理位置字段
    latitude DECIMAL(10, 6) COMMENT '纬度',
    longitude DECIMAL(10, 6) COMMENT '经度',

    -- 索引
    INDEX idx_location (latitude, longitude),
    INDEX idx_status (status, is_deleted)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='门店信息表';
```

**2. JSON字段查询**：
```sql
-- 查询有停车场的门店
SELECT * FROM gym_store
WHERE JSON_EXTRACT(facilities, '$.hasParking') = true;

-- 查询图片数量大于3的门店
SELECT * FROM gym_store
WHERE JSON_LENGTH(images) > 3;

-- 更新JSON字段
UPDATE gym_store
SET facilities = JSON_SET(facilities, '$.equipmentCount', 200)
WHERE id = 1;
```

**3. 空间索引优化**（MySQL 8.0+）：
```sql
-- 创建空间索引（需要POINT类型）
ALTER TABLE gym_store ADD COLUMN location POINT;

-- 更新空间字段
UPDATE gym_store
SET location = ST_GeomFromText(CONCAT('POINT(', longitude, ' ', latitude, ')'), 4326);

-- 创建空间索引
CREATE SPATIAL INDEX idx_spatial_location ON gym_store(location);

-- 空间查询（矩形区域筛选，比Haversine快10倍）
SELECT * FROM gym_store
WHERE ST_Distance_Sphere(
    location,
    ST_GeomFromText('POINT(116.3972 39.9075)', 4326)
) <= 10000;  -- 10公里
```

#### 3.1.3 连接配置

**application.yml**：
```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/fitness_platform?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
    username: root
    password: your_password

    # HikariCP连接池配置（Spring Boot 3.x默认）
    hikari:
      minimum-idle: 5                # 最小空闲连接
      maximum-pool-size: 20          # 最大连接数
      connection-timeout: 30000      # 连接超时（毫秒）
      idle-timeout: 600000           # 空闲超时（10分钟）
      max-lifetime: 1800000          # 连接最大存活时间（30分钟）
```

#### 3.1.4 实现功能清单

| 功能模块 | 表名 | 核心字段 | 特殊技术 |
|---------|------|---------|---------|
| 用户管理 | `user` | phone, password_hash | BCrypt加密 |
| 门店管理 | `gym_store` | latitude, longitude, facilities(JSON) | 空间索引, JSON |
| 健康档案 | `health_record` | user_id, body_data(JSON) | JSON字段 |
| 课程管理 | `course`, `course_schedule` | start_time, end_time | 时间范围查询 |
| 订单支付 | `order_info`, `payment_record` | order_no, transaction_id | 事务一致性 |
| 教练管理 | `coach`, `coach_certification` | rating, service_count | 聚合统计 |

---

### 3.2 Redis 缓存与会话管理

#### 3.2.1 技术特性

**选型原因**：
- ✅ 高性能缓存（QPS 10万+）
- ✅ 分布式Session存储
- ✅ Token黑名单管理
- ✅ 限流计数器
- ✅ 热点数据缓存

**依赖配置**：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>  <!-- Lettuce连接池 -->
</dependency>
```

#### 3.2.2 连接配置

**application.yml**：
```yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password: your_password
      database: 0           # Admin端使用db0

      # Lettuce连接池配置
      lettuce:
        pool:
          max-active: 8     # 最大连接数
          max-idle: 8       # 最大空闲连接
          min-idle: 2       # 最小空闲连接
          max-wait: 3000ms  # 获取连接最大等待时间

      # 连接超时
      timeout: 5000ms
```

#### 3.2.3 Redis配置类

```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 使用Jackson序列化
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(
            mapper.getPolymorphicTypeValidator(),
            ObjectMapper.DefaultTyping.NON_FINAL
        );
        serializer.setObjectMapper(mapper);

        // Key使用String序列化
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());

        // Value使用JSON序列化
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))  // 默认过期时间30分钟
                .disableCachingNullValues();       // 不缓存null值

        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
    }
}
```

#### 3.2.4 项目中的应用

**1. Token黑名单管理**（用户退出登录）：
```java
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final RedisTemplate<String, String> redisTemplate;
    private final JwtUtil jwtUtil;

    @Override
    public void logout(String token) {
        // 1. 解析Token获取过期时间
        Claims claims = jwtUtil.parseToken(token);
        Date expiration = claims.getExpiration();
        long ttl = expiration.getTime() - System.currentTimeMillis();

        // 2. 将Token加入黑名单，过期时间与Token一致
        String blacklistKey = "token:blacklist:" + token;
        redisTemplate.opsForValue().set(blacklistKey, "1", ttl, TimeUnit.MILLISECONDS);
    }
}
```

**2. 验证码存储**（5分钟有效期）：
```java
@Service
@RequiredArgsConstructor
public class SmsService {

    private final RedisTemplate<String, String> redisTemplate;

    // 发送验证码
    public void sendVerificationCode(String phone) {
        // 1. 生成6位随机验证码
        String code = String.format("%06d", new Random().nextInt(999999));

        // 2. 存入Redis（5分钟过期）
        String key = "sms:code:" + phone;
        redisTemplate.opsForValue().set(key, code, 5, TimeUnit.MINUTES);

        // 3. 调用短信服务发送（见后文）
        sendSms(phone, code);
    }

    // 验证验证码
    public boolean verifyCode(String phone, String code) {
        String key = "sms:code:" + phone;
        String storedCode = redisTemplate.opsForValue().get(key);

        if (code.equals(storedCode)) {
            // 验证成功后删除验证码（防止重复使用）
            redisTemplate.delete(key);
            return true;
        }
        return false;
    }
}
```

**3. 热点数据缓存**（门店详情）：
```java
@Service
@RequiredArgsConstructor
public class GymStoreServiceImpl implements GymStoreService {

    private final GymStoreMapper gymStoreMapper;
    private final RedisTemplate<String, Object> redisTemplate;

    @Override
    @Cacheable(value = "store:detail", key = "#id", unless = "#result == null")
    public GymStoreDetailVO getStoreDetail(Long id) {
        // 1. 尝试从Redis缓存获取
        String cacheKey = "store:detail:" + id;
        GymStoreDetailVO cached = (GymStoreDetailVO) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 2. 缓存未命中，查询数据库
        GymStoreDetailVO detailVO = gymStoreMapper.selectStoreDetail(id);
        if (detailVO == null) {
            throw new BusinessException("门店不存在");
        }

        // 3. 写入Redis缓存（30分钟过期）
        redisTemplate.opsForValue().set(cacheKey, detailVO, 30, TimeUnit.MINUTES);
        return detailVO;
    }

    @Override
    @CacheEvict(value = "store:detail", key = "#updateDTO.id")
    public void updateStore(GymStoreUpdateDTO updateDTO) {
        // 更新数据库
        GymStore gymStore = BeanUtil.copyProperties(updateDTO, GymStore.class);
        this.updateById(gymStore);

        // 注解自动删除缓存
    }
}
```

**4. 接口限流**（防止恶意请求）：
```java
@Aspect
@Component
@RequiredArgsConstructor
public class RateLimitAspect {

    private final RedisTemplate<String, String> redisTemplate;

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        // 1. 获取限流key（IP地址或用户ID）
        String key = "rate_limit:" + getClientIP() + ":" + point.getSignature().toShortString();

        // 2. 获取当前计数
        String countStr = redisTemplate.opsForValue().get(key);
        int count = countStr == null ? 0 : Integer.parseInt(countStr);

        // 3. 判断是否超过限流阈值
        if (count >= rateLimit.maxCount()) {
            throw new BusinessException("请求过于频繁，请稍后再试");
        }

        // 4. 计数器+1
        redisTemplate.opsForValue().increment(key);

        // 5. 设置过期时间（首次请求时）
        if (count == 0) {
            redisTemplate.expire(key, rateLimit.time(), rateLimit.timeUnit());
        }

        // 6. 执行业务方法
        return point.proceed();
    }
}

// 使用示例
@RestController
public class AuthController {

    @RateLimit(maxCount = 5, time = 1, timeUnit = TimeUnit.MINUTES)  // 1分钟最多5次
    @PostMapping("/send-code")
    public Result<Void> sendCode(@RequestParam String phone) {
        // 发送验证码逻辑
    }
}
```

**5. 分布式锁**（防止重复下单）：
```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final RedisTemplate<String, String> redisTemplate;

    public void createOrder(CreateOrderDTO orderDTO) {
        Long userId = UserContext.getUserId();
        String lockKey = "order:lock:" + userId;

        // 尝试获取分布式锁（10秒超时）
        Boolean locked = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);

        if (Boolean.FALSE.equals(locked)) {
            throw new BusinessException("订单创建中，请勿重复提交");
        }

        try {
            // 执行下单逻辑
            doCreateOrder(orderDTO);
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey);
        }
    }
}
```

#### 3.2.5 实现功能清单

| 功能 | Redis数据类型 | Key格式 | 过期时间 | 用途 |
|------|--------------|---------|---------|------|
| Token黑名单 | String | `token:blacklist:{token}` | Token剩余时间 | 退出登录 |
| 验证码 | String | `sms:code:{phone}` | 5分钟 | 登录/注册 |
| 门店详情缓存 | String | `store:detail:{id}` | 30分钟 | 热点数据 |
| 限流计数器 | String | `rate_limit:{ip}:{method}` | 自定义 | 接口防刷 |
| 分布式锁 | String | `order:lock:{userId}` | 10秒 | 防重复下单 |
| 用户Session | Hash | `session:{userId}` | 24小时 | 多端登录 |
| 附近门店 | Geo | `store:location` | 永久 | 地理位置查询 |

---

### 3.3 MinIO 对象存储

#### 3.3.1 技术特性

**选型原因**：
- ✅ 开源免费（vs 阿里云OSS按量收费）
- ✅ S3 API兼容（可无缝迁移）
- ✅ 高性能（单节点 100+ GB/s）
- ✅ 支持纠删码（数据冗余保护）
- ✅ 私有化部署（数据安全可控）

**与云存储对比**：

| 特性 | MinIO | 阿里云OSS | 腾讯云COS |
|------|-------|----------|----------|
| 成本 | 免费（自建服务器） | 0.12元/GB/月 + 流量费 | 0.118元/GB/月 + 流量费 |
| 部署 | 本地/私有云 | 公有云 | 公有云 |
| 带宽 | 局域网千兆 | 受运营商限制 | 受运营商限制 |
| CDN | 需自建 | 内置CDN | 内置CDN |
| 适用场景 | 开发测试/内网应用 | 生产环境/公网访问 | 生产环境/公网访问 |

#### 3.3.2 依赖配置

```xml
<dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    <version>8.2.0</version>
</dependency>
```

#### 3.3.3 完整配置与实现

**1. 配置属性类** (`common/config/MinioProperties.java`)：
```java
@Data
@Configuration
@ConfigurationProperties(prefix = "minio")
public class MinioProperties {
    private String endpoint;      // MinIO服务地址: http://localhost:9000
    private String accessKey;     // 访问密钥（默认 minioadmin）
    private String secretKey;     // 秘密密钥（默认 minioadmin）
    private String bucketName;    // 存储桶名称: fitness-platform
}
```

**2. MinIO客户端配置** (`common/config/MinioConfiguration.java`)：
```java
@Configuration
@EnableConfigurationProperties(MinioProperties.class)
public class MinioConfiguration {

    @Bean
    public MinioClient minioClient(MinioProperties properties) {
        return MinioClient.builder()
                .endpoint(properties.getEndpoint())
                .credentials(properties.getAccessKey(), properties.getSecretKey())
                .build();
    }
}
```

**3. MinIO工具类** (`common/util/MinioUtil.java`)：
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class MinioUtil {

    private final MinioClient minioClient;
    private final MinioProperties minioProperties;

    /**
     * 上传文件到MinIO
     * @param file 文件对象
     * @param folder 存储文件夹（如 "store/images"）
     * @return 文件访问URL
     */
    public String uploadFile(MultipartFile file, String folder) throws Exception {
        // 1. 确保Bucket存在
        createBucketIfNotExists();

        // 2. 生成唯一文件名: UUID_原始文件名
        String originalFilename = file.getOriginalFilename();
        String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
        String fileName = UUID.randomUUID() + extension;
        String objectName = folder + "/" + fileName;

        // 3. 上传文件
        minioClient.putObject(
                PutObjectArgs.builder()
                        .bucket(minioProperties.getBucketName())
                        .object(objectName)
                        .stream(file.getInputStream(), file.getSize(), -1)
                        .contentType(file.getContentType())
                        .build()
        );

        // 4. 返回访问URL
        return minioProperties.getEndpoint() + "/" +
               minioProperties.getBucketName() + "/" +
               objectName;
    }

    /**
     * 自动创建Bucket并设置公开读策略
     */
    private void createBucketIfNotExists() throws Exception {
        String bucketName = minioProperties.getBucketName();

        // 检查Bucket是否存在
        boolean exists = minioClient.bucketExists(
                BucketExistsArgs.builder().bucket(bucketName).build()
        );

        if (!exists) {
            // 创建Bucket
            minioClient.makeBucket(
                    MakeBucketArgs.builder().bucket(bucketName).build()
            );
            log.info("MinIO Bucket创建成功: {}", bucketName);

            // 设置公开读策略（允许匿名访问）
            String policy = """
            {
                "Version": "2012-10-17",
                "Statement": [{
                    "Effect": "Allow",
                    "Principal": {"AWS": ["*"]},
                    "Action": ["s3:GetObject"],
                    "Resource": ["arn:aws:s3:::%s/*"]
                }]
            }
            """.formatted(bucketName);

            minioClient.setBucketPolicy(
                    SetBucketPolicyArgs.builder()
                            .bucket(bucketName)
                            .config(policy)
                            .build()
            );
            log.info("MinIO Bucket策略设置成功");
        }
    }

    /**
     * 删除文件
     * @param fileUrl 文件完整URL
     */
    public void deleteFile(String fileUrl) throws Exception {
        // 从URL提取对象名
        String bucketName = minioProperties.getBucketName();
        int index = fileUrl.indexOf(bucketName) + bucketName.length() + 1;
        String objectName = fileUrl.substring(index);

        minioClient.removeObject(
                RemoveObjectArgs.builder()
                        .bucket(bucketName)
                        .object(objectName)
                        .build()
        );
        log.info("MinIO文件删除成功: {}", objectName);
    }

    /**
     * 批量删除文件
     * @param fileUrls 文件URL列表
     */
    public void deleteFiles(List<String> fileUrls) {
        fileUrls.forEach(url -> {
            try {
                deleteFile(url);
            } catch (Exception e) {
                log.error("文件删除失败: {}", url, e);
            }
        });
    }

    /**
     * 获取文件下载URL（带过期时间）
     * @param objectName 对象名称
     * @param expirySeconds 过期时间（秒）
     * @return 预签名URL
     */
    public String getPresignedUrl(String objectName, int expirySeconds) throws Exception {
        return minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                        .bucket(minioProperties.getBucketName())
                        .object(objectName)
                        .expiry(expirySeconds)
                        .build()
        );
    }
}
```

**4. application.yml配置**：
```yaml
# MinIO对象存储配置
minio:
  endpoint: http://localhost:9000          # MinIO服务地址
  access-key: minioadmin                   # 访问密钥
  secret-key: minioadmin                   # 秘密密钥
  bucket-name: fitness-platform            # 存储桶名称

# Spring文件上传配置
spring:
  servlet:
    multipart:
      enabled: true                        # 启用文件上传
      max-file-size: 10MB                  # 单个文件最大10MB
      max-request-size: 20MB               # 整个请求最大20MB
```

#### 3.3.4 MinIO部署指南

**方式1: Docker部署（推荐）**：
```bash
# 1. 拉取镜像
docker pull minio/minio:latest

# 2. 运行容器
docker run -d \
  -p 9000:9000 \
  -p 9001:9001 \
  --name minio-server \
  -e "MINIO_ROOT_USER=minioadmin" \
  -e "MINIO_ROOT_PASSWORD=minioadmin" \
  -v D:/minio-data:/data \
  minio/minio server /data --console-address ":9001"

# 3. 验证部署
curl http://localhost:9000/minio/health/live
# 响应: OK
```

**方式2: Windows可执行文件**：
```powershell
# 1. 下载MinIO Windows版本
# 官网: https://min.io/download#/windows

# 2. 启动服务
.\minio.exe server D:\minio-data --console-address ":9001"

# 3. 访问控制台
# http://localhost:9001
# 登录: minioadmin / minioadmin
```

**方式3: Linux部署**：
```bash
# 1. 下载
wget https://dl.min.io/server/minio/release/linux-amd64/minio
chmod +x minio

# 2. 启动
./minio server /data --console-address ":9001"

# 3. 后台运行（systemd）
cat > /etc/systemd/system/minio.service <<EOF
[Unit]
Description=MinIO
After=network.target

[Service]
Type=simple
User=minio
ExecStart=/usr/local/bin/minio server /data --console-address ":9001"
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable minio
systemctl start minio
```

#### 3.3.5 项目中的应用

**1. 门店图片上传** (`GymStoreController.java`)：
```java
@RestController
@RequestMapping("/admin/gym-store")
@RequiredArgsConstructor
public class GymStoreController {

    private final MinioUtil minioUtil;

    @PostMapping("/upload-image")
    public Result<String> uploadImage(@RequestParam("file") MultipartFile file) {
        // 1. 验证文件
        if (file == null || file.isEmpty()) {
            return Result.fail("请选择要上传的图片");
        }

        // 2. 验证文件类型
        String contentType = file.getContentType();
        if (contentType == null || !contentType.startsWith("image/")) {
            return Result.fail("只支持上传图片文件");
        }

        // 3. 验证文件大小（10MB）
        if (file.getSize() > 10 * 1024 * 1024) {
            return Result.fail("图片大小不能超过10MB");
        }

        try {
            // 4. 上传到MinIO
            String fileUrl = minioUtil.uploadFile(file, "store/images");
            log.info("图片上传成功: {}", fileUrl);
            return Result.success(fileUrl);
        } catch (Exception e) {
            log.error("图片上传失败", e);
            return Result.fail("图片上传失败: " + e.getMessage());
        }
    }
}
```

**2. 用户头像上传** (`UserController.java`)：
```java
@PostMapping("/upload-avatar")
public Result<String> uploadAvatar(@RequestParam("file") MultipartFile file) {
    try {
        // 上传到 user/avatars 文件夹
        String avatarUrl = minioUtil.uploadFile(file, "user/avatars");

        // 更新用户头像字段
        Long userId = UserContext.getUserId();
        User user = new User();
        user.setId(userId);
        user.setAvatar(avatarUrl);
        userService.updateById(user);

        return Result.success(avatarUrl);
    } catch (Exception e) {
        return Result.fail("头像上传失败");
    }
}
```

**3. 健康文章封面图** (`HealthArticleController.java`)：
```java
@PostMapping("/upload-cover")
public Result<String> uploadCover(@RequestParam("file") MultipartFile file) {
    try {
        String coverUrl = minioUtil.uploadFile(file, "article/covers");
        return Result.success(coverUrl);
    } catch (Exception e) {
        return Result.fail("封面上传失败");
    }
}
```

**4. 删除文件示例**（更新门店时删除旧图片）：
```java
@Override
public void updateStore(GymStoreUpdateDTO updateDTO) {
    // 1. 查询旧数据
    GymStore oldStore = this.getById(updateDTO.getId());

    // 2. 对比图片列表，删除旧图片
    List<String> oldImages = parseJsonArray(oldStore.getImages());
    List<String> newImages = updateDTO.getImages();

    List<String> deletedImages = oldImages.stream()
            .filter(img -> !newImages.contains(img))
            .collect(Collectors.toList());

    if (!deletedImages.isEmpty()) {
        minioUtil.deleteFiles(deletedImages);
    }

    // 3. 更新门店信息
    GymStore gymStore = BeanUtil.copyProperties(updateDTO, GymStore.class);
    this.updateById(gymStore);
}
```

#### 3.3.6 实现功能清单

| 功能模块 | 存储路径 | 文件类型 | 大小限制 | 访问权限 |
|---------|---------|---------|---------|---------|
| 门店图片 | `store/images/` | jpg/png/jpeg | 10MB | 公开读 |
| 用户头像 | `user/avatars/` | jpg/png | 5MB | 公开读 |
| 文章封面 | `article/covers/` | jpg/png | 5MB | 公开读 |
| 课程视频 | `course/videos/` | mp4/avi | 500MB | 预签名URL |
| 体测报告 | `health/reports/` | pdf | 20MB | 预签名URL |
| 教练证书 | `coach/certificates/` | jpg/pdf | 10MB | 私有 |

**目录结构示例**：
```
fitness-platform (Bucket)
├── store/
│   ├── images/
│   │   ├── uuid1_store1.jpg
│   │   └── uuid2_store2.jpg
│   └── documents/
│       └── business_license.pdf
├── user/
│   ├── avatars/
│   │   └── uuid_avatar.jpg
│   └── id_cards/
│       └── uuid_idcard.jpg
├── article/
│   ├── covers/
│   └── images/
├── course/
│   └── videos/
└── health/
    └── reports/
```

---

## 四、外部API服务集成

### 4.1 高德地图API

#### 4.1.1 功能概述

**集成目的**：
- ✅ 地址转坐标（地理编码）
- ✅ 坐标转地址（逆地理编码）
- ✅ 实际路径距离计算（驾车/步行）
- ✅ 路径规划导航
- ✅ 周边POI查询

**与Haversine公式的关系**：
- Haversine：计算**直线距离**（已在项目中实现）
- 高德API：计算**实际路径距离**（道路距离）

#### 4.1.2 申请步骤

**第1步：注册开发者账号**
1. 访问：https://lbs.amap.com/
2. 点击右上角"注册/登录" → 手机号注册
3. 完成实名认证（个人/企业）

**第2步：创建应用**
1. 登录控制台：https://console.amap.com/dev/key/app
2. 点击"创建新应用"
   - 应用名称：`健身平台`
   - 应用类型：`Web服务`
3. 点击"添加Key"
   - Key名称：`后端API密钥`
   - 服务平台：`Web服务`
   - 白名单IP：留空（开发环境），生产填服务器IP

**第3步：获取API Key**
```
示例Key: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

**免费额度**（个人开发者）：
- 地理编码/逆地理编码：**30万次/日**
- 路径规划：**10万次/日**
- 距离测量：**10万次/日**

#### 4.1.3 依赖配置

**Maven依赖**（HTTP客户端）：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <!-- 包含RestTemplate -->
</dependency>

<!-- 或使用OkHttp -->
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.11.0</version>
</dependency>
```

**application.yml配置**：
```yaml
# 高德地图API配置
amap:
  api-key: YOUR_AMAP_API_KEY                    # 替换为实际Key
  web-service-url: https://restapi.amap.com     # API基础URL

  # API端点
  geocode-url: /v3/geocode/geo                  # 地理编码
  regeocode-url: /v3/geocode/regeo              # 逆地理编码
  distance-url: /v3/distance                    # 距离测量
  direction-walking-url: /v3/direction/walking  # 步行路径
  direction-driving-url: /v3/direction/driving  # 驾车路径
```

#### 4.1.4 集成实现

**1. 配置属性类** (`common/config/AmapProperties.java`)：
```java
@Data
@Configuration
@ConfigurationProperties(prefix = "amap")
public class AmapProperties {
    private String apiKey;
    private String webServiceUrl;
    private String geocodeUrl;
    private String regeocodeUrl;
    private String distanceUrl;
    private String directionWalkingUrl;
    private String directionDrivingUrl;
}
```

**2. 高德地图服务类** (`common/service/AmapService.java`)：
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class AmapService {

    private final AmapProperties amapProperties;
    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * 地理编码：地址转坐标
     * @param address 详细地址
     * @param city 城市名称（可选，提高准确度）
     * @return {latitude: 39.996893, longitude: 116.481488}
     */
    public Map<String, Double> getLocationByAddress(String address, String city) {
        try {
            String url = amapProperties.getWebServiceUrl() +
                        amapProperties.getGeocodeUrl() +
                        "?key=" + amapProperties.getApiKey() +
                        "&address=" + URLEncoder.encode(address, StandardCharsets.UTF_8);

            if (StringUtils.hasText(city)) {
                url += "&city=" + URLEncoder.encode(city, StandardCharsets.UTF_8);
            }

            // 调用高德API
            String response = restTemplate.getForObject(url, String.class);
            JSONObject json = JSONObject.parseObject(response);

            // 解析响应
            if ("1".equals(json.getString("status")) && json.getInteger("count") > 0) {
                String location = json.getJSONArray("geocodes")
                                     .getJSONObject(0)
                                     .getString("location");
                String[] coords = location.split(",");

                return Map.of(
                    "longitude", Double.parseDouble(coords[0]),
                    "latitude", Double.parseDouble(coords[1])
                );
            } else {
                throw new BusinessException("地理编码失败: " + json.getString("info"));
            }
        } catch (Exception e) {
            log.error("地理编码异常: address={}, city={}", address, city, e);
            throw new BusinessException("地理编码服务异常");
        }
    }

    /**
     * 逆地理编码：坐标转地址
     * @param longitude 经度
     * @param latitude 纬度
     * @return 格式化地址
     */
    public String getAddressByLocation(Double longitude, Double latitude) {
        try {
            String url = amapProperties.getWebServiceUrl() +
                        amapProperties.getRegeocodeUrl() +
                        "?key=" + amapProperties.getApiKey() +
                        "&location=" + longitude + "," + latitude;

            String response = restTemplate.getForObject(url, String.class);
            JSONObject json = JSONObject.parseObject(response);

            if ("1".equals(json.getString("status"))) {
                return json.getJSONObject("regeocode")
                          .getString("formatted_address");
            } else {
                throw new BusinessException("逆地理编码失败");
            }
        } catch (Exception e) {
            log.error("逆地理编码异常: lon={}, lat={}", longitude, latitude, e);
            throw new BusinessException("逆地理编码服务异常");
        }
    }

    /**
     * 距离测量：计算实际路径距离
     * @param originLon 起点经度
     * @param originLat 起点纬度
     * @param destLon 终点经度
     * @param destLat 终点纬度
     * @param type 1=驾车距离, 0=直线距离
     * @return {distance: 12.58(公里), duration: 22(分钟)}
     */
    public Map<String, Object> calculateDistance(
            Double originLon, Double originLat,
            Double destLon, Double destLat,
            Integer type) {
        try {
            String url = amapProperties.getWebServiceUrl() +
                        amapProperties.getDistanceUrl() +
                        "?key=" + amapProperties.getApiKey() +
                        "&origins=" + originLon + "," + originLat +
                        "&destination=" + destLon + "," + destLat +
                        "&type=" + type;

            String response = restTemplate.getForObject(url, String.class);
            JSONObject json = JSONObject.parseObject(response);

            if ("1".equals(json.getString("status"))) {
                JSONObject result = json.getJSONArray("results").getJSONObject(0);

                return Map.of(
                    "distance", result.getDouble("distance") / 1000,  // 米转公里
                    "duration", result.getInteger("duration") / 60    // 秒转分钟
                );
            } else {
                throw new BusinessException("距离测量失败");
            }
        } catch (Exception e) {
            log.error("距离测量异常", e);
            throw new BusinessException("距离测量服务异常");
        }
    }

    /**
     * 路径规划：获取导航路线
     * @param originLon 起点经度
     * @param originLat 起点纬度
     * @param destLon 终点经度
     * @param destLat 终点纬度
     * @param type 1=步行, 2=驾车
     * @return 路径详情
     */
    public Map<String, Object> getRoute(
            Double originLon, Double originLat,
            Double destLon, Double destLat,
            Integer type) {
        try {
            String apiUrl = type == 1 ?
                    amapProperties.getDirectionWalkingUrl() :
                    amapProperties.getDirectionDrivingUrl();

            String url = amapProperties.getWebServiceUrl() + apiUrl +
                        "?key=" + amapProperties.getApiKey() +
                        "&origin=" + originLon + "," + originLat +
                        "&destination=" + destLon + "," + destLat;

            String response = restTemplate.getForObject(url, String.class);
            JSONObject json = JSONObject.parseObject(response);

            if ("1".equals(json.getString("status"))) {
                JSONObject route = json.getJSONObject("route");
                JSONObject path = route.getJSONArray("paths").getJSONObject(0);

                return Map.of(
                    "distance", path.getDouble("distance") / 1000,
                    "duration", path.getInteger("duration") / 60,
                    "steps", path.getJSONArray("steps")  // 导航步骤
                );
            } else {
                throw new BusinessException("路径规划失败");
            }
        } catch (Exception e) {
            log.error("路径规划异常", e);
            throw new BusinessException("路径规划服务异常");
        }
    }
}
```

**3. Controller中使用**：

**新增门店时自动获取坐标**：
```java
@RestController
@RequestMapping("/admin/gym-store")
@RequiredArgsConstructor
public class GymStoreController {

    private final AmapService amapService;

    // 新增接口：地址转坐标
    @GetMapping("/geocode")
    public Result<Map<String, Double>> geocode(
            @RequestParam String address,
            @RequestParam(required = false) String city) {
        Map<String, Double> location = amapService.getLocationByAddress(address, city);
        return Result.success(location);
    }
}
```

**前端使用**（Admin端新增门店）：
```javascript
// 用户输入地址后，自动调用接口获取坐标
async function onAddressChange(address, city) {
  try {
    const response = await axios.get('/admin/gym-store/geocode', {
      params: { address, city }
    });

    // 自动填充经纬度
    formData.latitude = response.data.data.latitude;
    formData.longitude = response.data.data.longitude;
  } catch (error) {
    console.error('地理编码失败', error);
  }
}
```

**App端门店详情显示实际距离**：
```java
@GetMapping("/{id}")
public Result<GymStoreDetailVO> detail(
        @PathVariable Long id,
        @RequestParam(required = false) Double userLatitude,
        @RequestParam(required = false) Double userLongitude,
        @RequestParam(defaultValue = "0") Integer distanceType) {  // 0=直线, 1=驾车

    GymStoreDetailVO detailVO = appGymStoreService.getStoreDetail(id, userLatitude, userLongitude);

    // 如果需要实际路径距离
    if (distanceType == 1 && userLatitude != null && userLongitude != null) {
        Map<String, Object> realDistance = amapService.calculateDistance(
            userLongitude, userLatitude,
            detailVO.getLongitude(), detailVO.getLatitude(),
            1  // 驾车距离
        );
        detailVO.setDistance((Double) realDistance.get("distance"));
        detailVO.setDuration((Integer) realDistance.get("duration"));
    }

    return Result.success(detailVO);
}
```

#### 4.1.5 前端地图展示

**引入高德地图JS API**（Vue 3）：
```html
<!-- public/index.html -->
<script src="https://webapi.amap.com/maps?v=2.0&key=YOUR_WEB_KEY"></script>
```

**地图组件**：
```vue
<template>
  <div id="map-container" style="width:100%;height:400px;"></div>
</template>

<script setup>
import { onMounted } from 'vue';

const props = defineProps({
  stores: Array,  // 门店列表
  userLocation: Object  // 用户位置 {lat, lng}
});

onMounted(() => {
  // 初始化地图
  const map = new AMap.Map('map-container', {
    center: [props.userLocation.lng, props.userLocation.lat],
    zoom: 12
  });

  // 添加用户位置标记
  new AMap.Marker({
    position: [props.userLocation.lng, props.userLocation.lat],
    icon: '//a.amap.com/jsapi_demos/static/demo-center/icons/poi-marker-default.png',
    title: '我的位置'
  }).setMap(map);

  // 添加门店标记
  props.stores.forEach(store => {
    const marker = new AMap.Marker({
      position: [store.longitude, store.latitude],
      title: store.storeName
    });

    // 点击标记显示详情
    marker.on('click', () => {
      const infoWindow = new AMap.InfoWindow({
        content: `
          <div style="padding:10px;">
            <h3>${store.storeName}</h3>
            <p>${store.address}</p>
            <p>距离: ${store.distance}公里</p>
            <button onclick="viewDetail(${store.id})">查看详情</button>
          </div>
        `
      });
      infoWindow.open(map, marker.getPosition());
    });

    map.add(marker);
  });
});
</script>
```

**唤起高德地图APP导航**：
```javascript
function navigateToStore(storeLat, storeLon, storeName) {
  // iOS
  if (/(iPhone|iPad|iPod)/i.test(navigator.userAgent)) {
    window.location.href = `iosamap://path?sourceApplication=健身平台&dlat=${storeLat}&dlon=${storeLon}&dname=${storeName}&dev=0&t=0`;
  }
  // Android
  else if (/Android/i.test(navigator.userAgent)) {
    window.location.href = `androidamap://route?sourceApplication=健身平台&dlat=${storeLat}&dlon=${storeLon}&dname=${storeName}&dev=0&t=0`;
  }
  // Web端（打开高德地图网页版）
  else {
    window.open(`https://uri.amap.com/navigation?to=${storeLon},${storeLat},${storeName}&mode=walk&src=健身平台`);
  }
}
```

#### 4.1.6 实现功能清单

| 功能 | API端点 | 项目实现位置 | 状态 |
|------|--------|-------------|------|
| 地址转坐标 | `/v3/geocode/geo` | `AmapService.getLocationByAddress()` | 🔧 待集成 |
| 坐标转地址 | `/v3/geocode/regeo` | `AmapService.getAddressByLocation()` | 🔧 待集成 |
| 距离测量 | `/v3/distance` | `AmapService.calculateDistance()` | 🔧 待集成 |
| 路径规划 | `/v3/direction/walking` | `AmapService.getRoute()` | 🔧 待集成 |
| 前端地图展示 | JS API 2.0 | Vue组件 | 🔧 待集成 |
| 直线距离计算 | - | Haversine公式 | ✅ 已实现 |

---

### 4.2 短信验证码服务

#### 4.2.1 功能概述

**集成目的**：
- ✅ 用户注册验证
- ✅ 登录验证码
- ✅ 找回密码验证
- ✅ 修改手机号验证
- ✅ 敏感操作二次验证

**推荐服务商对比**：

| 服务商 | 价格 | 免费额度 | 到达率 | 验证码有效期 | 推荐度 |
|--------|------|---------|-------|-------------|--------|
| 阿里云SMS | 0.045元/条 | 首月100条 | 99%+ | 5分钟 | ⭐⭐⭐⭐⭐ |
| 腾讯云SMS | 0.045元/条 | 首月100条 | 99%+ | 5分钟 | ⭐⭐⭐⭐⭐ |
| 网易云信 | 0.05元/条 | 体验版100条/月 | 98%+ | 5分钟 | ⭐⭐⭐⭐ |
| 容联云 | 0.04元/条 | 体验版50条 | 98%+ | 5分钟 | ⭐⭐⭐ |

#### 4.2.2 阿里云SMS集成方案

**第1步：开通服务**
1. 登录阿里云控制台：https://dysms.console.aliyun.com/
2. 开通短信服务
3. 创建签名（如"健身平台"）
4. 创建模板（如"您的验证码为${code}，5分钟内有效"）

**第2步：获取凭证**
- AccessKey ID：`LTAI5tXXXXXXXXXXXXXX`
- AccessKey Secret：`xxxxxxxxxxxxxxxxxxxxxxxXXXXXX`
- 签名名称：`健身平台`
- 模板CODE：`SMS_123456789`

**依赖配置**：
```xml
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>dysmsapi20170525</artifactId>
    <version>2.0.24</version>
</dependency>
```

**配置文件**：
```yaml
# 阿里云短信配置
aliyun:
  sms:
    access-key-id: LTAI5tXXXXXXXXXXXXXX
    access-key-secret: xxxxxxxxxxxxxxxxxxxxxxxXXXXXX
    sign-name: 健身平台
    template-code: SMS_123456789
    region-id: cn-hangzhou
```

**集成实现**：

**1. 配置属性类** (`common/config/AliyunSmsProperties.java`)：
```java
@Data
@Configuration
@ConfigurationProperties(prefix = "aliyun.sms")
public class AliyunSmsProperties {
    private String accessKeyId;
    private String accessKeySecret;
    private String signName;
    private String templateCode;
    private String regionId;
}
```

**2. 短信服务类** (`common/service/SmsService.java`)：
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class SmsService {

    private final AliyunSmsProperties smsProperties;
    private final RedisTemplate<String, String> redisTemplate;

    /**
     * 发送验证码
     * @param phone 手机号
     * @return 验证码（开发环境返回，生产环境不返回）
     */
    public String sendVerificationCode(String phone) {
        // 1. 验证手机号格式
        if (!phone.matches("^1[3-9]\\d{9}$")) {
            throw new BusinessException("手机号格式不正确");
        }

        // 2. 限流检查（同一手机号1分钟内只能发送1次）
        String rateLimitKey = "sms:rate_limit:" + phone;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(rateLimitKey))) {
            throw new BusinessException("发送过于频繁，请稍后再试");
        }

        // 3. 生成6位随机验证码
        String code = String.format("%06d", new Random().nextInt(999999));

        // 4. 存入Redis（5分钟有效期）
        String codeKey = "sms:code:" + phone;
        redisTemplate.opsForValue().set(codeKey, code, 5, TimeUnit.MINUTES);

        // 5. 设置限流（1分钟）
        redisTemplate.opsForValue().set(rateLimitKey, "1", 1, TimeUnit.MINUTES);

        // 6. 调用阿里云SDK发送短信
        boolean success = sendSmsToAliyun(phone, code);
        if (!success) {
            throw new BusinessException("短信发送失败");
        }

        log.info("验证码发送成功: phone={}, code={}", phone, code);

        // 开发环境返回验证码（方便测试）
        return code;
    }

    /**
     * 验证验证码
     * @param phone 手机号
     * @param code 验证码
     * @return 是否验证成功
     */
    public boolean verifyCode(String phone, String code) {
        String codeKey = "sms:code:" + phone;
        String storedCode = redisTemplate.opsForValue().get(codeKey);

        if (code.equals(storedCode)) {
            // 验证成功后删除验证码（防止重复使用）
            redisTemplate.delete(codeKey);
            return true;
        }
        return false;
    }

    /**
     * 调用阿里云SDK发送短信
     */
    private boolean sendSmsToAliyun(String phone, String code) {
        try {
            // 创建客户端
            Config config = new Config()
                    .setAccessKeyId(smsProperties.getAccessKeyId())
                    .setAccessKeySecret(smsProperties.getAccessKeySecret())
                    .setRegionId(smsProperties.getRegionId());

            Client client = new Client(config);

            // 构建请求
            SendSmsRequest request = new SendSmsRequest()
                    .setPhoneNumbers(phone)
                    .setSignName(smsProperties.getSignName())
                    .setTemplateCode(smsProperties.getTemplateCode())
                    .setTemplateParam("{\"code\":\"" + code + "\"}");

            // 发送请求
            SendSmsResponse response = client.sendSms(request);

            // 检查响应
            return "OK".equals(response.getBody().getCode());
        } catch (Exception e) {
            log.error("阿里云短信发送异常: phone={}", phone, e);
            return false;
        }
    }
}
```

**3. Controller中使用**：
```java
@RestController
@RequestMapping("/app/auth")
@RequiredArgsConstructor
public class AuthController {

    private final SmsService smsService;

    @PostMapping("/send-code")
    @RateLimit(maxCount = 5, time = 1, timeUnit = TimeUnit.MINUTES)  // 限流
    public Result<Void> sendCode(@RequestParam String phone) {
        smsService.sendVerificationCode(phone);
        return Result.success();
    }

    @PostMapping("/login")
    public Result<LoginVO> login(@Valid @RequestBody LoginDTO loginDTO) {
        // 验证验证码
        boolean valid = smsService.verifyCode(loginDTO.getPhone(), loginDTO.getCode());
        if (!valid) {
            return Result.fail("验证码错误或已过期");
        }

        // 登录逻辑...
        return Result.success(loginVO);
    }
}
```

#### 4.2.3 开发环境Mock方案

**配置开关**：
```yaml
# 开发环境配置
sms:
  mock-enabled: true  # 启用Mock，不实际发送短信
  mock-code: "123456" # 固定验证码
```

**Mock实现**：
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class SmsService {

    @Value("${sms.mock-enabled:false}")
    private boolean mockEnabled;

    @Value("${sms.mock-code:123456}")
    private String mockCode;

    public String sendVerificationCode(String phone) {
        // Mock模式直接返回固定验证码
        if (mockEnabled) {
            String codeKey = "sms:code:" + phone;
            redisTemplate.opsForValue().set(codeKey, mockCode, 5, TimeUnit.MINUTES);
            log.info("[Mock] 验证码: {}", mockCode);
            return mockCode;
        }

        // 生产环境正常发送
        // ...
    }
}
```

#### 4.2.4 实现功能清单

| 功能 | 接口路径 | 状态 | 说明 |
|------|---------|------|------|
| 发送注册验证码 | `POST /app/auth/send-code` | 🔧 待集成 | 1分钟限流 |
| 发送登录验证码 | `POST /app/auth/send-code` | 🔧 待集成 | 复用同一接口 |
| 验证码校验 | 内部方法 | 🔧 待集成 | Redis存储 |
| Mock模式 | 配置开关 | 🔧 待集成 | 开发环境使用 |

---

### 4.3 支付服务集成

#### 4.3.1 功能概述

**集成目的**：
- ✅ 课程购买支付
- ✅ 会员卡充值
- ✅ 私教服务支付
- ✅ 订单退款

**推荐支付方式**：

| 支付方式 | 费率 | 结算周期 | 适用场景 | 推荐度 |
|---------|------|---------|---------|--------|
| 微信支付 | 0.6% | T+1 | 移动端/小程序 | ⭐⭐⭐⭐⭐ |
| 支付宝 | 0.6% | T+1 | Web端/移动端 | ⭐⭐⭐⭐⭐ |
| 银联支付 | 0.5% | T+1 | PC端 | ⭐⭐⭐ |
| PayPal | 3.4%+$0.3 | T+3 | 国际支付 | ⭐⭐ |

#### 4.3.2 微信支付集成方案（V3版本）

**第1步：申请资质**
1. 注册微信商户平台：https://pay.weixin.qq.com/
2. 提交资质认证（营业执照、法人身份证等）
3. 签署协议，开通支付功能

**第2步：获取凭证**
- 商户号（mchId）：`1234567890`
- API密钥（apiV3Key）：`xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`
- 商户证书序列号：`ABCDEF1234567890`
- APIv3私钥文件：`apiclient_key.pem`

**依赖配置**：
```xml
<dependency>
    <groupId>com.github.wechatpay-apiv3</groupId>
    <artifactId>wechatpay-java</artifactId>
    <version>0.2.12</version>
</dependency>
```

**配置文件**：
```yaml
# 微信支付配置
wechat:
  pay:
    app-id: wx1234567890abcdef                    # 公众号/小程序AppID
    mch-id: 1234567890                            # 商户号
    api-v3-key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  # APIv3密钥
    merchant-serial-number: ABCDEF1234567890      # 证书序列号
    private-key-path: classpath:cert/apiclient_key.pem  # 私钥路径
    notify-url: https://yourdomain.com/api/payment/notify  # 支付回调URL
```

**集成实现**：

**1. 配置类** (`common/config/WechatPayConfig.java`)：
```java
@Configuration
@ConfigurationProperties(prefix = "wechat.pay")
@Data
public class WechatPayConfig {
    private String appId;
    private String mchId;
    private String apiV3Key;
    private String merchantSerialNumber;
    private String privateKeyPath;
    private String notifyUrl;

    @Bean
    public RSAAutoCertificateConfig rsaAutoCertificateConfig() {
        return new RSAAutoCertificateConfig.Builder()
                .merchantId(mchId)
                .privateKeyFromPath(privateKeyPath)
                .merchantSerialNumber(merchantSerialNumber)
                .apiV3Key(apiV3Key)
                .build();
    }
}
```

**2. 支付服务类** (`common/service/WechatPayService.java`)：
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class WechatPayService {

    private final WechatPayConfig wechatPayConfig;
    private final RSAAutoCertificateConfig certificateConfig;
    private final OrderService orderService;

    /**
     * 创建支付订单（JSAPI支付）
     * @param orderNo 订单号
     * @param amount 支付金额（分）
     * @param description 商品描述
     * @param openid 用户openid
     * @return 预支付交易会话标识（用于前端调起支付）
     */
    public Map<String, String> createOrder(String orderNo, Integer amount,
                                          String description, String openid) {
        try {
            // 构建请求参数
            JsapiPaymentRequest request = new JsapiPaymentRequest();
            request.setAppid(wechatPayConfig.getAppId());
            request.setMchid(wechatPayConfig.getMchId());
            request.setDescription(description);
            request.setOutTradeNo(orderNo);
            request.setNotifyUrl(wechatPayConfig.getNotifyUrl());

            // 金额信息
            Amount amountInfo = new Amount();
            amountInfo.setTotal(amount);  // 单位：分
            amountInfo.setCurrency("CNY");
            request.setAmount(amountInfo);

            // 用户标识
            Payer payer = new Payer();
            payer.setOpenid(openid);
            request.setPayer(payer);

            // 调用微信支付API
            NativePayService payService = new NativePayService.Builder()
                    .config(certificateConfig)
                    .build();

            PrepayResponse response = payService.prepay(request);
            String prepayId = response.getPrepayId();

            // 生成前端调起支付的参数
            return generateJsapiPayParams(prepayId);
        } catch (Exception e) {
            log.error("创建支付订单失败: orderNo={}", orderNo, e);
            throw new BusinessException("创建支付订单失败");
        }
    }

    /**
     * 生成JSAPI支付参数
     */
    private Map<String, String> generateJsapiPayParams(String prepayId) {
        String timestamp = String.valueOf(System.currentTimeMillis() / 1000);
        String nonceStr = UUID.randomUUID().toString().replace("-", "");
        String packageStr = "prepay_id=" + prepayId;

        // 按照微信规范计算签名
        String signStr = wechatPayConfig.getAppId() + "\n" +
                        timestamp + "\n" +
                        nonceStr + "\n" +
                        packageStr + "\n";

        String paySign = rsaSign(signStr);

        return Map.of(
            "timeStamp", timestamp,
            "nonceStr", nonceStr,
            "package", packageStr,
            "signType", "RSA",
            "paySign", paySign
        );
    }

    /**
     * 支付回调处理
     * @param requestBody 回调请求体
     * @param signature 签名
     * @param nonce 随机串
     * @param timestamp 时间戳
     * @param serialNumber 证书序列号
     */
    public void handlePaymentNotify(String requestBody, String signature,
                                    String nonce, String timestamp, String serialNumber) {
        try {
            // 1. 验证签名
            NotificationParser parser = new NotificationParser(certificateConfig);
            RequestParam requestParam = new RequestParam.Builder()
                    .serialNumber(serialNumber)
                    .nonce(nonce)
                    .signature(signature)
                    .timestamp(timestamp)
                    .body(requestBody)
                    .build();

            Transaction transaction = parser.parse(requestParam, Transaction.class);

            // 2. 验证订单状态
            if ("SUCCESS".equals(transaction.getTradeState())) {
                String orderNo = transaction.getOutTradeNo();
                String transactionId = transaction.getTransactionId();
                Integer amount = transaction.getAmount().getTotal();

                // 3. 更新订单状态
                orderService.updateOrderPaid(orderNo, transactionId, amount);
                log.info("支付成功: orderNo={}, transactionId={}", orderNo, transactionId);
            }
        } catch (Exception e) {
            log.error("支付回调处理失败", e);
            throw new BusinessException("支付回调处理失败");
        }
    }

    /**
     * 查询订单支付状态
     */
    public String queryOrderStatus(String orderNo) {
        try {
            QueryOrderByOutTradeNoRequest request = new QueryOrderByOutTradeNoRequest();
            request.setMchid(wechatPayConfig.getMchId());
            request.setOutTradeNo(orderNo);

            NativePayService payService = new NativePayService.Builder()
                    .config(certificateConfig)
                    .build();

            Transaction transaction = payService.queryOrderByOutTradeNo(request);
            return transaction.getTradeState();  // SUCCESS, NOTPAY, CLOSED等
        } catch (Exception e) {
            log.error("查询订单状态失败: orderNo={}", orderNo, e);
            return "UNKNOWN";
        }
    }

    /**
     * 申请退款
     */
    public void refund(String orderNo, String refundNo, Integer amount, Integer refundAmount) {
        try {
            CreateRefundRequest request = new CreateRefundRequest();
            request.setOutTradeNo(orderNo);
            request.setOutRefundNo(refundNo);
            request.setReason("用户申请退款");
            request.setNotifyUrl(wechatPayConfig.getNotifyUrl());

            // 金额信息
            RefundAmount amountInfo = new RefundAmount();
            amountInfo.setTotal(amount);      // 原订单金额
            amountInfo.setRefund(refundAmount);  // 退款金额
            amountInfo.setCurrency("CNY");
            request.setAmount(amountInfo);

            // 调用退款API
            RefundService refundService = new RefundService.Builder()
                    .config(certificateConfig)
                    .build();

            Refund refund = refundService.create(request);
            log.info("退款申请成功: refundId={}", refund.getRefundId());
        } catch (Exception e) {
            log.error("退款失败: orderNo={}, refundNo={}", orderNo, refundNo, e);
            throw new BusinessException("退款申请失败");
        }
    }
}
```

**3. Controller实现**：
```java
@RestController
@RequestMapping("/app/payment")
@RequiredArgsConstructor
public class PaymentController {

    private final WechatPayService wechatPayService;
    private final OrderService orderService;

    // 创建支付订单
    @PostMapping("/create")
    public Result<Map<String, String>> createPayment(@Valid @RequestBody CreatePaymentDTO dto) {
        // 1. 创建业务订单
        OrderInfo order = orderService.createOrder(dto);

        // 2. 调用微信支付
        Map<String, String> payParams = wechatPayService.createOrder(
            order.getOrderNo(),
            order.getAmount(),
            order.getDescription(),
            dto.getOpenid()
        );

        return Result.success(payParams);
    }

    // 支付回调（微信服务器调用）
    @PostMapping("/notify")
    public Map<String, String> paymentNotify(
            @RequestBody String requestBody,
            @RequestHeader("Wechatpay-Signature") String signature,
            @RequestHeader("Wechatpay-Nonce") String nonce,
            @RequestHeader("Wechatpay-Timestamp") String timestamp,
            @RequestHeader("Wechatpay-Serial") String serialNumber) {

        try {
            wechatPayService.handlePaymentNotify(requestBody, signature, nonce, timestamp, serialNumber);

            // 返回成功响应
            return Map.of("code", "SUCCESS", "message", "成功");
        } catch (Exception e) {
            // 返回失败响应
            return Map.of("code", "FAIL", "message", e.getMessage());
        }
    }

    // 查询订单状态
    @GetMapping("/query/{orderNo}")
    public Result<String> queryOrderStatus(@PathVariable String orderNo) {
        String status = wechatPayService.queryOrderStatus(orderNo);
        return Result.success(status);
    }

    // 申请退款
    @PostMapping("/refund")
    public Result<Void> refund(@Valid @RequestBody RefundDTO dto) {
        OrderInfo order = orderService.getByOrderNo(dto.getOrderNo());

        wechatPayService.refund(
            order.getOrderNo(),
            dto.getRefundNo(),
            order.getAmount(),
            dto.getRefundAmount()
        );

        return Result.success();
    }
}
```

**4. 前端调起支付**（小程序）：
```javascript
// 获取支付参数
const response = await wx.request({
  url: '/app/payment/create',
  method: 'POST',
  data: {
    courseId: 1,
    amount: 9900,  // 99元
    openid: wx.getStorageSync('openid')
  }
});

const payParams = response.data.data;

// 调起微信支付
wx.requestPayment({
  timeStamp: payParams.timeStamp,
  nonceStr: payParams.nonceStr,
  package: payParams.package,
  signType: payParams.signType,
  paySign: payParams.paySign,
  success(res) {
    wx.showToast({ title: '支付成功' });
    // 跳转到订单详情
  },
  fail(err) {
    wx.showToast({ title: '支付失败', icon: 'none' });
  }
});
```

#### 4.3.3 实现功能清单

| 功能 | 接口路径 | 状态 | 说明 |
|------|---------|------|------|
| 创建支付订单 | `POST /app/payment/create` | 🚀 可选 | JSAPI/Native支付 |
| 支付回调处理 | `POST /app/payment/notify` | 🚀 可选 | 微信服务器调用 |
| 查询订单状态 | `GET /app/payment/query/{orderNo}` | 🚀 可选 | 主动查询 |
| 申请退款 | `POST /app/payment/refund` | 🚀 可选 | 7天内可退 |
| 退款回调处理 | `POST /app/payment/refund-notify` | 🚀 可选 | 微信服务器调用 |

---

## 五、项目实现功能清单

### 5.1 已实现功能（✅）

| 模块 | 功能 | 涉及技术 | 实现位置 |
|------|------|---------|---------|
| **用户管理** | 用户注册/登录 | JWT + Redis | `web-app/controller/AuthController` |
| **用户管理** | Token黑名单管理 | Redis String | `AuthService.logout()` |
| **用户管理** | 用户注销审核 | MyBatis-Plus | `web-admin/controller/UserController` |
| **角色管理** | 角色分配/权限管理 | MyBatis-Plus | `web-admin/controller/RoleController` |
| **教练管理** | 教练资格申请/审核 | MyBatis-Plus + 状态机 | `CoachCertificationController` |
| **教练管理** | 教练离职申请 | MyBatis-Plus | `CoachResignationController` |
| **教练管理** | 教练日程安排 | MyBatis-Plus | `CoachScheduleController` |
| **教练管理** | 教练咨询服务 | MyBatis-Plus | `CoachConsultationController` |
| **门店管理** | 门店CRUD操作 | MyBatis-Plus | `web-admin/controller/GymStoreController` |
| **门店管理** | 门店图片上传 | MinIO | `GymStoreController.uploadImage()` |
| **门店管理** | 门店详情JSON解析 | MySQL JSON + Jackson | `GymStoreService` |
| **门店查询** | 附近门店查询 | Haversine公式 + SQL | `AppGymStoreController.nearby()` |
| **门店查询** | 距离计算 | Haversine公式 | `AppGymStoreService.calculateDistance()` |
| **门店查询** | 门店搜索 | MyBatis-Plus | `AppGymStoreService.searchStores()` |
| **API文档** | Swagger分组管理 | Knife4j | `Knife4jConfiguration` |
| **数据库** | 逻辑删除 | MyBatis-Plus @TableLogic | `BaseEntity.isDeleted` |
| **数据库** | 自动填充 | MyBatis-Plus MetaObjectHandler | `MyMetaObjectHandler` |
| **数据库** | 分页查询 | MyBatis-Plus Page | 所有Service |

### 5.2 待集成功能（🔧）

| 模块 | 功能 | 涉及技术 | 优先级 |
|------|------|---------|--------|
| **地图服务** | 地址转坐标 | 高德地图API | P1 |
| **地图服务** | 坐标转地址 | 高德地图API | P1 |
| **地图服务** | 实际距离计算 | 高德地图API | P2 |
| **地图服务** | 路径规划 | 高德地图API | P2 |
| **地图服务** | 前端地图展示 | 高德地图JS API | P2 |
| **短信服务** | 验证码发送 | 阿里云SMS | P1 |
| **短信服务** | 验证码校验 | Redis + 阿里云SMS | P1 |
| **支付服务** | 微信支付 | 微信支付V3 API | P3 |
| **支付服务** | 支付宝支付 | 支付宝SDK | P3 |
| **缓存优化** | 热点数据缓存 | Redis + Spring Cache | P2 |
| **缓存优化** | 分布式锁 | Redis SETNX | P2 |
| **数据库优化** | 空间索引 | MySQL SPATIAL INDEX | P2 |

**优先级说明**：
- **P1（高）**：核心业务必需，建议优先集成
- **P2（中）**：增强用户体验，按需集成
- **P3（低）**：扩展功能，后期集成

### 5.3 技术债务与优化建议

| 问题 | 影响 | 解决方案 | 工作量 |
|------|------|---------|--------|
| 开发环境验证码固定 | 测试不便 | 集成短信服务Mock模式 | 1天 |
| 附近门店查询性能 | 数据量大时慢 | 添加MySQL空间索引 | 1天 |
| 图片未压缩 | 存储成本高 | 集成图片压缩工具 | 2天 |
| 缺少接口限流 | 易被攻击 | 完善RateLimit注解 | 2天 |
| 日志未集成ELK | 排查问题困难 | 集成Logstash | 3天 |
| 缺少监控告警 | 故障发现慢 | 集成Prometheus | 3天 |

---

## 六、完整集成实战指南

### 6.1 快速启动清单（开发环境）

**步骤1：环境准备**
```bash
# 1. 安装MySQL 8.0
# 2. 安装Redis 7.0
# 3. 启动MinIO（Docker）
docker run -d -p 9000:9000 -p 9001:9001 --name minio \
  -e "MINIO_ROOT_USER=minioadmin" \
  -e "MINIO_ROOT_PASSWORD=minioadmin" \
  minio/minio server /data --console-address ":9001"
```

**步骤2：数据库初始化**
```bash
# 1. 创建数据库
mysql -u root -p
CREATE DATABASE fitness_platform CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 2. 导入SQL文件
mysql -u root -p fitness_platform < db/fitness_platform.sql
```

**步骤3：配置文件修改**
```yaml
# web-admin/src/main/resources/application.yml
# web-app/src/main/resources/application.yml

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/fitness_platform
    username: root
    password: YOUR_PASSWORD  # 修改为实际密码

  data:
    redis:
      host: localhost
      password: YOUR_PASSWORD  # 修改为实际密码

minio:
  endpoint: http://localhost:9000
  access-key: minioadmin
  secret-key: minioadmin
```

**步骤4：启动项目**
```bash
# Admin端
cd web/web-admin
mvn spring-boot:run

# App端（另开终端）
cd web/web-app
mvn spring-boot:run
```

**步骤5：验证启动**
```bash
# Admin端Swagger
http://localhost:8080/doc.html

# App端Swagger
http://localhost:8081/doc.html

# MinIO控制台
http://localhost:9001
```

### 6.2 高德地图API集成步骤

**步骤1：申请Key**
1. 访问：https://console.amap.com/dev/key/app
2. 创建应用，获取Key

**步骤2：添加配置**
```yaml
# application.yml
amap:
  api-key: YOUR_AMAP_API_KEY
  web-service-url: https://restapi.amap.com
```

**步骤3：使用AmapService**
```java
@Autowired
private AmapService amapService;

// 地址转坐标
Map<String, Double> location = amapService.getLocationByAddress("北京市朝阳区望京SOHO", "北京");
// 返回: {latitude: 39.996893, longitude: 116.481488}
```

### 6.3 短信服务集成步骤

**步骤1：开通阿里云SMS**
1. 访问：https://dysms.console.aliyun.com/
2. 创建签名和模板

**步骤2：添加依赖**
```xml
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>dysmsapi20170525</artifactId>
    <version>2.0.24</version>
</dependency>
```

**步骤3：添加配置**
```yaml
aliyun:
  sms:
    access-key-id: YOUR_ACCESS_KEY_ID
    access-key-secret: YOUR_ACCESS_KEY_SECRET
    sign-name: 健身平台
    template-code: SMS_123456789
```

**步骤4：使用SmsService**
```java
@Autowired
private SmsService smsService;

// 发送验证码
smsService.sendVerificationCode("13800138000");

// 验证验证码
boolean valid = smsService.verifyCode("13800138000", "123456");
```

### 6.4 微信支付集成步骤

**步骤1：申请商户号**
1. 访问：https://pay.weixin.qq.com/
2. 提交资质认证

**步骤2：下载证书**
1. 登录商户平台
2. 下载API证书（apiclient_key.pem）
3. 放置到 `src/main/resources/cert/`

**步骤3：添加依赖**
```xml
<dependency>
    <groupId>com.github.wechatpay-apiv3</groupId>
    <artifactId>wechatpay-java</artifactId>
    <version>0.2.12</version>
</dependency>
```

**步骤4：添加配置**
```yaml
wechat:
  pay:
    app-id: wx1234567890abcdef
    mch-id: 1234567890
    api-v3-key: YOUR_API_V3_KEY
    merchant-serial-number: YOUR_SERIAL_NUMBER
    private-key-path: classpath:cert/apiclient_key.pem
    notify-url: https://yourdomain.com/api/payment/notify
```

**步骤5：使用WechatPayService**
```java
@Autowired
private WechatPayService wechatPayService;

// 创建支付订单
Map<String, String> payParams = wechatPayService.createOrder(
    "ORDER123456",
    9900,  // 99元
    "课程购买",
    "oUpF8uMuAJO_M2pxb1Q9zNjWeS6o"
);
```

---

## 七、生产环境部署清单

### 7.1 环境配置差异

| 配置项 | 开发环境 | 生产环境 |
|-------|---------|---------|
| 数据库地址 | localhost | 内网IP/域名 |
| Redis密码 | 简单密码 | 强密码 |
| MinIO endpoint | http://localhost:9000 | https://oss.yourdomain.com |
| JWT secret | 默认密钥 | 256位随机密钥 |
| 日志级别 | DEBUG | INFO/WARN |
| 短信Mock | 启用 | 禁用 |
| 高德API白名单 | 未设置 | 服务器IP |
| 微信支付回调URL | 内网穿透 | 正式域名 |

### 7.2 安全加固

**1. 数据库安全**
```sql
-- 创建专用数据库用户
CREATE USER 'fitness_app'@'%' IDENTIFIED BY 'STRONG_PASSWORD';
GRANT SELECT, INSERT, UPDATE, DELETE ON fitness_platform.* TO 'fitness_app'@'%';
FLUSH PRIVILEGES;

-- 禁止root远程登录
DELETE FROM mysql.user WHERE User='root' AND Host!='localhost';
```

**2. Redis安全**
```bash
# redis.conf
requirepass YOUR_STRONG_PASSWORD
bind 127.0.0.1  # 仅允许本地访问
rename-command FLUSHDB ""  # 禁用危险命令
```

**3. MinIO安全**
```bash
# 修改默认密钥
MINIO_ROOT_USER=admin_custom
MINIO_ROOT_PASSWORD=STRONG_PASSWORD_HERE

# 启用HTTPS
./minio server /data --certs-dir /root/.minio/certs
```

**4. 接口安全**
```java
// 添加IP白名单拦截器
@Component
public class IpWhitelistInterceptor implements HandlerInterceptor {

    private static final List<String> WHITELIST = Arrays.asList(
        "127.0.0.1",
        "10.0.0.0/8",  // 内网IP段
        "YOUR_SERVER_IP"
    );

    @Override
    public boolean preHandle(HttpServletRequest request, ...) {
        String clientIp = getClientIP(request);
        if (!isInWhitelist(clientIp)) {
            throw new ForbiddenException("IP未授权");
        }
        return true;
    }
}
```

### 7.3 性能优化

**1. MySQL优化**
```sql
-- 创建索引
CREATE INDEX idx_user_phone ON user(phone);
CREATE INDEX idx_store_status ON gym_store(status, is_deleted);
CREATE SPATIAL INDEX idx_location ON gym_store(location);

-- 查询优化
-- 使用EXPLAIN分析慢查询
EXPLAIN SELECT * FROM gym_store WHERE status=1 AND is_deleted=0;
```

**2. Redis优化**
```yaml
# application-prod.yml
spring:
  data:
    redis:
      lettuce:
        pool:
          max-active: 20  # 生产环境增加连接数
          max-idle: 10
```

**3. JVM参数优化**
```bash
java -jar \
  -Xms2g -Xmx2g \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  fitness-app.jar
```

### 7.4 监控告警

**集成Prometheus + Grafana**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

### 7.5 备份策略

**MySQL备份**
```bash
# 每日凌晨3点备份
0 3 * * * /usr/bin/mysqldump -u root -p fitness_platform > /backup/db_$(date +\%Y\%m\%d).sql
```

**Redis备份**
```bash
# 启用AOF持久化
appendonly yes
appendfsync everysec

# 定时备份RDB
save 900 1
save 300 10
save 60 10000
```

**MinIO备份**
```bash
# 使用mc工具同步到另一台服务器
mc mirror minio1/fitness-platform minio2/fitness-platform-backup
```

---

## 附录

### A. 常用命令速查

**Docker命令**
```bash
# 启动MinIO
docker start minio-server

# 停止MinIO
docker stop minio-server

# 查看日志
docker logs -f minio-server
```

**MySQL命令**
```bash
# 导入SQL
mysql -u root -p fitness_platform < backup.sql

# 导出SQL
mysqldump -u root -p fitness_platform > backup.sql

# 查看进程
SHOW PROCESSLIST;
```

**Redis命令**
```bash
# 查看所有key
redis-cli KEYS *

# 查看内存使用
redis-cli INFO memory

# 清空数据库（谨慎）
redis-cli FLUSHDB
```

### B. 技术支持资源

| 技术 | 官方文档 | 社区 |
|------|---------|------|
| Spring Boot | https://spring.io/projects/spring-boot | Stack Overflow |
| MyBatis-Plus | https://baomidou.com/ | GitHub Issues |
| MinIO | https://min.io/docs/minio/linux/index.html | Slack |
| 高德地图 | https://lbs.amap.com/api | 开发者论坛 |
| 阿里云SMS | https://help.aliyun.com/product/44282.html | 工单系统 |
| 微信支付 | https://pay.weixin.qq.com/wiki/doc/apiv3/index.shtml | 商户社区 |

### C. 开发规范

**代码规范**
- 遵循阿里巴巴Java开发手册
- 使用Lombok简化代码
- Controller只做参数校验和调用Service
- Service层处理业务逻辑
- 复杂SQL写在Mapper XML中

**Git提交规范**
```
feat: 新增门店管理功能
fix: 修复Token过期判断逻辑
docs: 更新API文档
style: 代码格式化
refactor: 重构用户Service
test: 添加单元测试
chore: 升级依赖版本
```

**API设计规范**
- RESTful风格
- 统一使用Result封装
- HTTP状态码规范使用
- 接口版本控制（v1, v2）

---

**文档维护**：
- 每次新增外部服务集成时更新本文档
- 每次架构调整时更新架构图
- 每次优化配置时更新最佳实践

**文档版本历史**：
- v1.0 (2025-01-24): 初始版本，涵盖MySQL/Redis/MinIO/高德地图/短信/支付

---

**结语**：
本文档详细记录了健身平台项目的所有技术架构、中间件集成方案和外部API集成方法。建议开发团队：
1. 按照优先级（P1 → P2 → P3）逐步集成外部服务
2. 开发环境先使用Mock模式验证流程
3. 生产环境严格遵循安全加固清单
4. 定期review技术债务并优化

如有疑问，请参考各技术的官方文档或联系架构负责人。
